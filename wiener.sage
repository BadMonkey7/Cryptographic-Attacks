import time

def recover(e,N):
    cf = convergents(e/N)
    for index, k in enumerate(cf[1:]):
        d0 = k.denominator()
        k = k.numerator()
        if k != 0 and (e * d0 - 1) % k == 0:
            
            phi = (e*d0 - 1) //k
            s = (N-phi+1)
            f = x^2 - s*x + N
            b = s^2 - 4*N
            
            if b > 0 and b.is_square():
                d = d0
                roots = zip(*f.roots())[0]
                if len(roots) == 2 and prod(roots) == N:
                    return d
            else:
                continue

    return -1
    

def wiener(c,e,N):
    d = recover(e,N)
    return hex(Integer(pow(c,d,N)))

def test():
    
    e = 165528674684553774754161107952508373110624366523537426971950721796143115780129435315899759675151336726943047090419484833345443949104434072639959175019000332954933802344468968633829926100061874628202284567388558408274913523076548466524630414081156553457145524778651651092522168245814433643807177041677885126141
    N = 380654536359671023755976891498668045392440824270475526144618987828344270045182740160077144588766610702530210398859909208327353118643014342338185873507801667054475298636689473117890228196755174002229463306397132008619636921625801645435089242900101841738546712222819150058222758938346094596787521134065656721069
    c = 28597279540907845916896971896622579477094800063195357522872064880257242094960385766598625167905853008548847375383954235220740939323699019293114186352234014502088314580612832215339119526402952330072190226295529377477338762835260671088018604333831307855443665750192375976613594120878626650442933628547520861194
    
    m = wiener(c,e,N)
    print(m)
test()